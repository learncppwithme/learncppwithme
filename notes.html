<!DOCTYPE html>
<html lang="en">
<head>
	<title>learn c++ with me... | notes</title>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<!-- google analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y6YQE57BVZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-Y6YQE57BVZ');
</script>
<style>
.collapsible {
  background-color: #737373;
  cursor: pointer;
  padding: 18px;
  width: 100%;
  border: none;
  text-align: left;
  outline: none;
  font-size: 15px;
}

.active, .collapsible:hover {
  background-color: #5A5858;
}

.content {
  padding: 0 18px;
  display: none;
  overflow: hidden;
  background-color: #737373;
}

.padding {
  padding-right: 100px;
  padding-left: 100px;
}
</style>
<body>
<!-- nav bar -->
	<table border="0" cellpadding="0" cellspacing="0" width="50%" align="center">
		<tr class=nav>
		<th><a href="index.html">home</a></th>
            <th><a href="blog.html">blog</a></th>
            <th><a href="resources.html">resources</a></th>
            <th><a href="aboutme.html">about me</a></th>
            <th>notes</th>
        </tr>
	</table>
<!-- header --> 
<br>
<table width="60%" height="40" border="0" align="center">
    <tbody><tr> 
      <td width="73%" valign="top" height="18" align="center"> 
        <img src="notesheader.gif" width="250" height="75"> 
      </td>  
</tr></tbody></table>
<br>
<!-- collapsible -->
<table width=75% border="0" align="center">
<tr class="padding">
    <td width=100% align="center" valign="top">
        <table width=100% border="1" bgcolor="#5A5858" cellspacing="2" cellpadding="4" align="center">
        <thead type="button" class="collapsible">
            <tr bgcolor="#5A5858"><th><h2>time complexity</h2></th></tr>
        </thead>
        <tbody bgcolor="#737373" class="content">
        <tr><td>
        <b>big o notation:</b> the worst case scenario of the complexity of an algorithm.
		&nbsp;for USACO programming questions submitted in C++ , solutions must run in 2 seconds or less.
		&nbsp;we can use big o notation to calculate how many operations it will take an algorithm to run, with <em>n</em> representing the input size.
		<br><br>
		so time complexity, in other words, is the upper bound for the number of steps an algorithm needs to run as a function of the input size.<br>
		we denote time complexity in <b>big o notation<b> by <em>O(f(n))</em>, but constant factors and lower order terms are usually left out from <em>f(n)</em>.
		<br>
		<pre>
		<code>
		int a = 5;
		int b = 7;
		int c = 4;
		int d = a + b + c + 153;
		// here’s an example of code that’s O(1), because it executes a constant number of operations.
		</code>
		</pre><br>
		input and output operations are also <em>O(1)</em>.
			<br><br>
			the time complexity of loops is the number of iterations it runs.
			<pre><code>
			//example one
			for(int i = 1; i <= n; i++) {
				// constant time code here
			}

			//example two
			int i = 0;
			while(i < n) {
				//constant time code here
				i++;
			}
			// both examples are O(n), because they are iterated n times.
			</code></pre>
			<br>
			<pre><code>
			for (int i = 1; i <= n + 457737; i++) { 	
				// constant time code here 
			}
			// because constant factors are lower order terms are ignored when measuring time complexity, the following code is also O(n).
			</code></pre>
			<pre><code>
			for (int i = 1; i <= n; i++) {
				for (int j = 1; j <= m; j++) {
					// constant time code here 	
				}
			}
			</code></pre>
			<br>
			the time complexity of multiple loops is found by multiplying the time complexities of each loop. this code is <em>O(nm)</em>, because the outer loop is <em>O(n)</em> and the inner loop is <em>O(m)</em>.
			<br>
			</pre><code>
			for (int i = 1; i <= n; i++) {
				for (int j = i; j <= n; j++) {
					// constant time code here
				}
			}
			// the outer loop will run O(n) times and since the inner loop can run from anywhere to 1 to n times (and big o notation calculates for worst case scenario), the inner loop is also considered O(n). so, this algorithm is O(n^2) because you multiply the complexities of both loops together! 
			</code></pre>
			<br>
			<pre><code>
			for (int i = 1; i <= n; i++) {
				for (int j = 1; j <= n; j++) {
					// constant time code here
				} 
			} 
			for (int i = 1; i <= m; i++) {
				// more constant time code here
			}
			// this code is considered O(n^2 + m) because the top block is O(n^2) and the bottom block is O(m).
			</code></pre>
			<br>
			<h3>common complexities and constraints</h3>
			<table border = 1 bgcolor="5A5858">
			  <tr>
				<td>constant</td>
				<td><em>O(1)</em></td>
			  </tr>
			  <tr>
				<td>logarithmic</td>
				<td><em>O(log(n))</em></td>
			  </tr>
			  <tr>
				<td>linear</td>
				<td><em>O(n)</em></td>
			  </tr>
			  <tr>
				<td>linearithmic</td>
				<td><em>O(n(log(n))</em></td>
			  </tr>
			  <tr>
				<td>quadric</td>
				<td><em>O(n^2)</em></td>
			  </tr>
			  <tr>
				<td>cubic</td>
				<td><em>O(n^3)</em></td>
			  </tr>
			  <tr>
				<td>exponential</td>
				<td><em>O(b^n)</em></td>
			  </tr>
			  <tr>
				<td>factorial</td>
				<td><em>O(n!)</em></td>
			  </tr>
			</table>
			<br><br>
			<ul>
			  <li>math formulas that calculate an answer: <em>O(1)</em></li>
			  <li>binary search: <em>O(log ⁡n)</em></li>
			  <li>sorted set/map or priority queue: <em>O(log ⁡n)</em> per     operation</li>
			  <li>prime factorization of an integer, or checking primality or compositeness of an integer naively: <em>O(√n)</em> (square root n)</li>
			  <li>reading in n items of input: <em>O(n)</em>
			</li>
			  <li>iterating through an array or a list of <em>n</em> elements: <em>O(n)</em></li>
			  <li>sorting: usually <em>O(n log ⁡n)</em> for default sorting algorithms (mergesort, Collections.sort, Arrays.sort)</li>
			  <li>iterating through all subsets of size <em>k</em> of the input elements: <em>O(n^k)</em>. for example, iterating through all triplets is <em>O(n^3)</em>.</li>
			  <li>iterating through all subsets of size <em>k</em> of the input elements: <em>O(n^k)</em>. for example, iterating through all triplets is <em>O(n^3)</em>.</li>
			  <li>iterating through all subsets: <em>O(2^n)</em></li>
			<li>iterating through all permutations: <em>O(n!)</em></em></li>
			</ul>

        </td></tr>
        </tbody></table>
    </td>
</tr>
<tr class="padding">
	<td width=100% align="center" valign="top">
        <table width=100% border="1" bgcolor="#5A5858" cellspacing="2" cellpadding="4" align="center">
        <thead type="button" class="collapsible">
            <tr bgcolor="#5A5858"><th><h2>data structures</h2></th></tr>
        </thead>
        <tbody bgcolor="#737373" class="content">
        <tr><td>
        <b>data structures</b> determine how data is organized for more efficient data access.
		&nbsp;you should evaluate which data structure works the <b>best</b> for your particular problem, because each data structure supports different operations.
		<br>
		in C++, <a href=“http://www.cplusplus.com/reference/stl/” target=_blank>standard library data structures</a> store any type of data, and when declaring the data structure, put the data type in the brackets below, like this:<br>
		<pre><code>
		vector<string> v;
		// this is a <b>vector</b> structure that only can store objects of type <b>string</b>. the vector is called <b>v</b>.
		</code></pre>
		<ul>
		  <li>nearly every standard library data type will support two methods:</li>
			<ul>
			  <li><code>size()</code>, which returns the number of elements in the data structure.</li>
			  <li><code>empty()</code>, which returns <code>true</code> if the data structure has nothing in it, and <code>false</code> if not.</li>
			</ul>
		</ul>
		
		
		<h3>arrays</h3>
		the array is one of the simplest data structures. in C++, there is also an <code>array</code> class in the STL (or <a href=“https://en.wikipedia.org/wiki/Standard_Template_Library” target=_blank>Standard Template Library</a>)<br>
		<pre><code>
		array<int, 25> arr;
		// an array named <b>arr</b> of 25 <b>int<b>s
		arr[5];
		// accesses the element at the 5th index
		</code></pre><br>
		<em>the array class supports normal STL operations of course! (<code>.empty()</code> and <code>.size()</code>) and the square-bracket access operator</em><br>
		arrays that are initialized locally using default syntax or array class are initialized to random numbers because C++ has no memory management. to initialize an array to zero, the main options are:
		<ul>
		  <li>use a for loop</li>
		  <li>declare the array globally</li>
			<ul><li>
			note: <b>local variables</b> are declared inside a function, and <b>global variables</b> are declared outside the function!
			</li></ul>
		</ul>
		  <li>declare the array with an empty list (like <code>int arr[25]{};</code>)</li>
		  <li>use a built-in function (like <code>std::fill_n(arr, 25, 0)</code> or <code>std::fill(arr, arr+25, 0)</code>)</li>
		  
		  
		<h3>dynamic arrays</h3>
		<b>dynamic arrays</b>, or <code>vector</code> in C++, support all functions of a normal array, can resize themselves to accommodate more elements, and can add/delete elements at the end in <em>O(1)</em> (or constant) time
		<pre><code>
		vector<int> v; 
		for(int i = 1; i <= 10; i++) {
			v.push_back(i);
		}
		// creates the vector v and adds the numbers 1-10 to it
		</code></pre>
		<code>g++</code> (the C++ compiler) will allow arrays of a variable length, making it <em>O(n)</em>:
		<pre><code>
		vector<int> v(n); // one way 
		vector<int> v; v.resize(n); // another way
		</code></pre>
		array-contest problems use mostly one-, two-, and three- dimensional static arrays. but, there might also be:
		<ul>
		  <li>dynamic arrays of dynamic arrays (vector<vector<int>>)</li>
		  <li>static arrays of dynamic arrays (array<vector<int>,5>)</li>
		  <li>dynamic arrays of static arrays (vector<array<int,5>>)</li>
		  <li>and so on…(so confusing i know!!)</li>
		</ul>
		<h3>iterating</h3>
		use a <b>for loop<b> as a way to iterate through all the elements of a dynamic/static array.
		<pre><code>
		vector<int> v{1,7,4,5,2}; 
		for (int i = 0; i < int(size(v)); i++) { 	
			cout << v[i] << " "; 
		} 
		cout << endl;
		</code></pre>
		<b>iterators</b>: we can also use iterators to do this! they allow you to traverse a container by pointing to any object in the container. NOT the same as a pointer!
		<br>
		<code>v.begin()</code> or <code>begin(v)</code> return an iterator pointing to the first element of vector <code>v</code>.
		<pre><code>
		for (vector<int>::iterator it = v.begin(); it != v.end(); ++it) { 	   
			cout << *it << " "; //prints the values in the vector using the iterator 
		}
		</code></pre>
		<pre><code>
		vector<int> v{1,7,4,5,2}; for (auto it = begin(v); it != end(v); it = next(it)) {
			cout << *it << " "; //prints the values in the vector using the iterator 
		}
		// this is another way to write the code before this, C++ 11 automatically infers the type of an object so you don’t need to write <b>vector<int></b> in the loop
		</code></pre>
		we can <em>also</em> use a for-each loop to do the same thing (this is the nature of coding, there are so many ways to do the exact same thing!)
		<code><pre>
		for (int element : v) { 	
		cout << element << " "; //prints the values in the vector 
		}
		// this is honestly probably the easiest way, to me it just makes the most sense…and it’s the shortest too lol
		</code></pre>
		<h3>inserting/erasing</h3>
		insertion and erasure in the middle of <code>vectors</code> are <em>O(n)</em>.
		<pre><code>
		vector<int> v; v.push_back(2); // [2]
		v.push_back(3); // [2, 3] 
		v.push_back(7); // [2, 3, 7] 
		v.push_back(5); // [2, 3, 7, 5]
		v[1] = 4; // sets element at index 1 to 4 -> [2, 4, 7, 5]
		v.erase(v.begin() + 1); // removes element at index 1 -> [2, 7, 5] 
		// this remove method is O(n); to be avoided 
		v.push_back(8); // [2, 7, 5, 8] 
		v.erase(v.end()-1); // [2, 7, 5] 
		// here, we remove the element from the end of the list; this is O(1).
		v.push_back(4); // [2, 7, 5, 4] 
		v.push_back(4); // [2, 7, 5, 4, 4] 
		v.push_back(9); // [2, 7, 5, 4, 4, 9] 
		cout << v[2]; // 5 
		v.erase(v.begin(), v.begin()+3); // [4, 4, 9] 
		// this erases the first three elements; O(n)
		//just a ton of examples!
		</code></pre>
		<h3>strings</h3>
		some basic string manipulation techniques that are a must-know: (<a href=“https://www.learncpp.com/cpp-tutorial/introduction-to-stdstring/” target=_blank>this resource</a> is especially helpful if you still don’t understand)
		<ul>
		  <li>reading strings from standard input:
		  <pre><code>
		  #include <string> 
		  int main() {
			std::string name {"Alex"}; // initialize name with string literal 
			"Alex" name = "John"; // change name to "John" 
			return name; 
		  }
		  </pre></code>
		  </li>
		  <li>
		  how to use <code>getline</code> and <code>cin</code> together:
		  <ul>
			<li><code>getline</code> reads characters from an input and puts them into a string</li>
			<li>this is because compilers stop reading the input stream as soon as it encounters a “ “ character</li>
			<li><code>cin</code> cannot read multi-word or multiline input!</li>
		  </ul>
		  <pre><code>
		  #include <string> // For std::string and std::getline 
		  #include <iostream> 
			int main() { 
		std::cout << "Enter your full name: ";
		std::string name{}; 
		std::getline(std::cin >> std::ws, name); // read a full line of text into name 

		std::cout << "Enter your age: "; 
		std::string age{}; 
		std::getline(std::cin >> std::ws, age); // read a full line of text into age 

		std::cout << "Your name is " << name << " and your age is " << age << '\n'; 

		return 0; }
		  </pre></code>
		  </li>
		  <li>
		  knowing how to sort/concatenate strings, and loop through a string’s characters:
		  <pre><code>
		  #include <iostream> 
		  #include<algorithm> 
		  using namespace std; // this means we don’t have to write “std::” before everything! 
		  int main(){ 
			string s; 
			cout << "Enter a string: ";
			cin >> s; sort(s.begin(), s.end()); // sort function included in <algorithm> 
			cout << "The sorted string is: " << s; 
			return 0; 
			  }
		  </code></pre>
		  the <code>sort()</code> function from the STL can be used to sort a string by using the <code>algorithm</code> header in your code.
		  <b>syntax:</b> <code>sort(first iterator, last iterator)</code><br>
		  &#10159; NOTE: only non-spaced strings can be sorted using the <code>sort()</code> function.
		  </li>
		  <li>
		  <b>concatenation</b>: adding strings together to make a new string.
		  <pre><code>
		  string firstName = "John"; 
		  string lastName = "Doe"; 
		  string fullName = firstName + " " + lastName; 
		  cout << fullName;
		  // the + operator can be used between strings to join them
		  </code></pre>
		  <pre><code>
		  string firstName = "John "; //add a space at the end of this string 
		  string lastName = "Doe"; 
		  string fullName = firstName.append(lastName); 
		  cout << fullName; // output: John Doe (not JohnDoe)!!!
		  // the append() function can also be used to concatenate strings
		  </code></pre>
		  </li>
		  <li>
		  looping through a string’s characters (easiest way is to use a <code>for</code> loop):
		  <pre><code>
		  #include <iostream> 
		  using namespace std; 
		  main() { 
			string s = "Hello World"; 
			for(int i = 0; i < s.length(); i++) { 
			  cout <<s.at(i) << endl; //get character at position i 
			} 
		  }
		  // length() is used to find the length of a string (don’t use it for any other data type!)
		  </pre></code>
		  </li>
		  <li>
		  how to get substrings with <code>string::substr:</code><br>
		  <code>std::substr()</code> takes two values (<code>pos</code> and <code>len</code>) and returns a newly constructed string object, with its value initialized to a substring of the original string.<br>
		  <b>syntax:</b> <code>string substr (size_t pos, size_t len) const;</code><br>
		  <b>parameters:</b>
			<ol>
			<li><b>pos:</b> Position of the first character to be copied.</li>
			<li><b>len:</b> Length of the sub-string.</li>
			<li><b>size_t:</b> It is an unsigned integral type.</li>
			</ol>
		  <pre><code>
		  #include <string.h>
		  #include <iostream>
		  using namespace std;
		 
		  int main()
		  {
			// Take any string
			string s1 = "Kelsey";

			// Copy two characters of s1 (starting from position 3)
			string r = s1.substr(3, 2);

			// prints the result
			cout << "String is: " << r;

			return 0;
		  }
		  // output "String is: se"
		  // note that the index of the first character is 0!
		  </code></pre>
		  </li>
		</ul>
		<h3>pairs and tuples</h3>
		<h4>pairs: can store two elements of different types.</h4><br>
		in C++, the following code for pairs is used: <code></code>
		<ul>
		  <li><code>pair<type1, type2> p</code>: creates the pair <code>p</code> with two elements, the first one being of <code>type1</code> and the second one being of <code>type2</code></li>
		  <li><code>make_pair(a, b)</code>: returns a pair with values <code>a</code>, <code>b</code></li>
		  <li><code>{a, b}</code>: with C++11 and above, this can be used as to create a pair, which is easier to write than <code>make_pair(a, b)</code> <i>but less intuitive in my opinion, so many references won’t use this</i></li>
		  <li><code>pair.first</code>: the first value of the pair</li>
		  <li><code>pair.second</code>: the second value of the pair</li>
		</ul>
		<pre><code>
		#include <bits/stdc++.h>
		using namespace std;

		int main() {
			pair<string, int> myPair1 = make_pair("Testing", 123);
			cout << myPair1.first << " " << myPair1.second << endl;
			myPair1.first = "It is possible to edit pairs after declaring them";
			cout << myPair1.first << " " << myPair1.second << endl;
			pair<string, string> myPair2 = {"Testing", "curly braces"};
			cout << myPair2.first << " " << myPair2.second << endl;
		}

		/* Output:
		Testing 123
		It is possible to edit pairs after declaring them 123
		Testing curly braces
		*/
		</code></pre>
		<h4>tuples: can store more than two elements of different types.</h4>
		in C++, the following code for tuples is used:
		<ul>
		  <li><code>tuple<type1, type2, ..., typeN> t</code>: creates a tuple named <code>t</code> with <code>N</code> elements, i'th one being of <code>typei</code></li>
		  <li><code>make_tuple(a, b, c, ..., d)</code>: returns a tuple with values written in the brackets</li>
		  <li><code>get i(t)</code>: Returns the <code>i</code>'th element of the tuple <code>t</code> (can also be used to change the element of a tuple)</li>
		  <ul><li>this operation only works for a constant value of <code>i</code> </li></ul>
		  <li><code>tie(a, b, c, ..., d) = t</code>: assigns <code>a, b, c, ..., d</code> to the elements of the tuple <code>t</code> accordingly</li>
		</ul>
		<pre><code>
		#include <bits/stdc++.h>
		using namespace std;

		int main() {
			int a = 3, b = 4, c = 5;
			tuple<int, int, int> t = tie(a, b, c);
			cout << get<0>(t) << " " << get<1>(t) << " " << get<2>(t) << endl;
			get<0>(t) = 7;
			cout << get<0>(t) << " " << get<1>(t) << " " << get<2>(t) << endl;

			tuple<string, string, int> tp2 = make_tuple("Hello", "world", 100);
			string s1, s2; int x;
			tie(s1, s2, x) = tp2;
			cout << s1 << " " << s2 << " " << x << endl;
		}

		/* Output:
		3 4 5
		7 4 5
		Hello world 100
		*/
		// you have to assign data types to a tuple before you assign values to it!
		</code></pre>
		<h3>memory allocation</h3>
		the USACO memory limit is 256 MB. to estimate how many values can be stored within this limit:
		<ol>
		  <li>total memory size in bytes: 256 MB = 256 * 10^6</li>
		  <li>divide the size (in bytes), of an <code>int</code> (4 bytes), or a <code>long long</code> (8 bytes), etc.</li>
		  <ol><li>the number of <code>ints</code> you are able to store is (256*10^6)/4 = 64 * 10^6.</li></ol>
		  <li>program overhead (which needs to be considered, especially with recursive functions) will reduce the amount of energy available.</li>
		  <ol>
			<li><a href=”https://stackoverflow.com/questions/2860234/what-is-overhead” target=_blank>program overhead:</a> the resources available to set up an operation</li>
			<li><a href=”https://www.geeksforgeeks.org/recursive-functions/” target=_blank>recursive functions:</a> a function that references itself</li>
		  </ol>
		</ol>
        </td></tr>
        </tbody></table>
    </td>
</tr>
<tr class="padding">
	<td width=100% align="center" valign="top">
        <table width=100% border="1" bgcolor="#5A5858" cellspacing="2" cellpadding="4" align="center">
        <thead type="button" class="collapsible">
            <tr bgcolor="#5A5858"><th><h2>sets and maps</h2></th></tr>
        </thead>
        <tbody bgcolor="#737373" class="content">
        <tr><td>
			<b>sets</b>: collections of elements that have no duplicates.<br><br>

			<h3>unordered sets</h3>
			<b>unordered sets</b> are stored through <a href=”https://www.google.com/search?q=hashing&oq=hashing&aqs=chrome..69i57j0i433i512l2j0i512l7.1743j0j7&sourceid=chrome&ie=UTF-8” target=_blank>hashing</a>. inserting, deleting, and searching for elements in these sets are all <em>O(1)</em>, and implemented by <code>std::unordered_set</code> under the <code><unordered_set></code> header.<br>
			examples of operations on an unordered set <code>s</code>:
			<ul>
			  <li><code>s.insert(x)</code>: adds the element <code>x</code> to <code>s</code> if not already present</li>
			  <li><code>s.erase(x</code>): removes the element <code>x</code> from <code>s</code> if already present</li>
			  <li><code>s.count(x)</code>: counts the number of instances <code>x</code> appears in <code>s</code> (so returns <code>1</code> if yes and <code>0</code> if no)</li>
			</ul><br>
			unordered sets work with primitive types (<code>int, char, bool, float, double, and wchar_t</code>) , but require custom hashing for things like vectors and pairs.
			<pre><code>
			unordered_set<int> s;
			s.insert(1);                 // {1}
			s.insert(4);                 // {1, 4}
			s.insert(2);                 // {1, 4, 2}
			s.insert(1);                 // does nothing because 1's already in the set
			cout << s.count(1) << endl;  // 1
			s.erase(1);                  // {2, 4}
			cout << s.count(5) << endl;  // 0
			s.erase(0);                  // does nothing because 0 wasn't in the set
			</code></pre>
			<h3>sorted sets</h3>
			<b>sorted sets</b> are sorted by order of element. inserting, deleting, and searching for elements in these sets are all <code>O(log N)</code>, with <code>N</code> being the number of elements in the set. they are implemented by typing <code>std::set</code> under the <code><set></code> header.<br>
			<code>std::set</code> includes the same operations as <code>std::unordered_set</code> (insertion, deletion, searches), as well as some additional ones:
			<ul><li>however these additional operations are more frequently seen in silver-level problems, so i won’t be covering them!</li></ul>
			<pre><code>
			set<int> s;
			s.insert(1);  // [1]
			s.insert(4);  // [1, 4]
			s.insert(2);  // [1, 2, 4]
			// Outputs 1, 2, and 4 on separate lines

			for (int element : s) { cout << element << endl; }
			// Iterates through a sorted set using a for each loop
			</code></pre>
			<h3>example</h3>
			there are two main methods to calculate the number of <b>distinct</b> values in a given list:<br>
			<h4>method 1 - using sets</h4>
			<pre><code>
			#include <bits/stdc++.h>

			using namespace std;

			int main() {
				int n;
				cin >> n;

				set<int> distinctNumbers;
				for (int i = 0; i < n; i++) {
					int number;
					cin >> number;
					distinctNumbers.insert(number);
				}

				cout << distinctNumbers.size() << endl;
			}
			// Insert all the numbers into a set and then print out its final size
			// This works because sets only store one copy of each value
			</code></pre>
			<h4>method 2 - using sorting</h4>
			this is probably the harder way, i would recommend when facing a problem like this to use a set instead!
			<pre><code>
			#include <bits/stdc++.h>
			using namespace std;

			int main() {
				int N;
				cin >> N;
				vector<int> arr(N);
				for (int i = 0; i < N; i++) cin >> arr[i];
				sort(arr.begin(), arr.end());
				int ans = 1;
				for (int i = 1; i < N; i++) {
					/*
					 * if the current number is different from the previous
					 * it is a distinct number so we add 1 to the answer
					 */
					ans += (arr[i] != arr[i - 1]);
				}
				cout << ans << endl;
				return 0;
			}
			</code></pre>
			<h3>maps</h3>
			<b>maps</b>: a set of entries, each with a unique <b>key</b> and a <b>value</b> (which can repeat).<br>
			maps have three methods:
			<ol>
			  <li>add a specified key-value pairing</li>
			  <li>retrieve value for a key</li>
			  <li>remove a key-value pairing from the map</li>
			</ol>
			<em>sorted</em> maps are sorted in order of key. inserting, deleting, and searching for elements in these sets are all <code>O(log N)</code>, and implemented by <code>std::map</code> (or <code>std::unordered_map</code> if unordered)<br>
			some <code>map</code> operations include (using <code>m</code> as its name):
			<ul>
			  <li><code>m[key]</code>: returns a reference to the value associated with the key <code>key</code>.</li>
			  <ul>
				<li>if key isn’t present in the map, then the value associated with it is constructed using the default constructor of the value type.</li>
				<ul><li>examples: value type = <code>int</code>, value set to <code>O</code>. value type = <code>std::string</code>, value set to <code>“”</code>.</li></ul>
			  </ul>
			  <li><code>m.count[key]</code>: returns the number of times the key is in the map (one or zero), therefore checking if that key exists.</li>
			  <li><code>m.erase[key]</code>: removes the map entry associated with the specified key (if the key was present at all).</li>
			<pre><code>
			map<int, int> m;
			m[1] = 5;                    // [(1, 5)]
			m[3] = 14;                   // [(1, 5); (3, 14)]
			m[2] = 7;                    // [(1, 5); (2, 7); (3, 14)]
			m[0] = -1;                   // [(0, -1); (1, 5); (2, 7); (3, 14)]
			m.erase(2);                  // [(0, -1); (1, 5); (3, 14)]
			cout << m[1] << endl;        // 5
			cout << m.count(7) << endl;  // 0
			cout << m.count(1) << endl;  // 1
			cout << m[2] << endl;        // 0
			</code></pre>
			<h4>iterating over maps</h4>
			use a <code>for</code> loop to iterate over maps.
			<ul>
			  <li>the <code>auto</code> keyword is used to iterate over any type of pair</li>
			  <li><code>std::map</code> stores entries as pairs in the form <code>{key, value}</code></li>
			</ul>
			<pre><code>
			// Both of these output the same thing
			for (const auto &x : m) { cout << x.first << " " << x.second << endl; }
			for (auto x : m) { cout << x.first << " " << x.second << endl; }
			/*
			the first method is preferred over the second because the second will make a copy of each element it iterates over.
			*/
			</code></pre>
			it’s generally a bad idea to add/remove elements from a map when iterating over it.<br>
			instead, just create a new map, or make a list of the keys to erase during the iteration to erase once finished.<br>		
        </td></tr>
        </tbody></table>
    </td>
</tr>
<tr class="padding">
	<td width=100% align="center" valign="top">
        <table width=100% border="1" bgcolor="#5A5858" cellspacing="2" cellpadding="4" align="center">
        <thead type="button" class="collapsible">
            <tr bgcolor="#5A5858"><th><h2>rectangle geometry</h2></th></tr>
        </thead>
        <tbody bgcolor="#737373" class="content">
        <tr><td>
		<h3>common formulas</h3>
		certain tasks in rectangle geometry questions show up again and again. for example, many problems require you to:
		<ul>
		  <li>find the overlapping area of 2+ rectangles based on their coordinates</li>
		  <li>determine whether 2 rectangles intersect</li>
		  <li><em>(these formulas only apply to rectangles w/ sides || to the coordinate axes.)</em></li>
		</ul>
		&#10159; a rectangle can be represented w/ two points: the top right corner (labeled as <em>tr</em>) and the bottom left corner (labeled as <em>bl</em>)<br>
		<em>assuming that increasing x moves to the right and increasing y moves up</em>
		<h3>finding area</h3>
		<ul>
		  <li>the normal formula for finding the area of an individual rectangle is of course, <em>w ⋅ l</em>.</li>
		  <li><b>length</b> is the length of vertical sides, and <b>width</b> is length of the horizontal sides.
		</ul>
		<ol>
		  <li><b>width</b> = <em>trₓ - blₓ</em></li>
		  <li><b>length</b> = <em>trᵧ - blᵧ</em></li>
		  <li><b>area</b> = <b>width</b> ⋅ <b>length</b></li>
		</ol>
		<h4>implementation</h4>
		<pre><code>
		long long area(int bl_x, int bl_y, int tr_x, int tr_y) {
			long long length = tr_y - bl_y;
			long long width = tr_x - bl_x;
			return length * width;
		}
		</code></pre>

		<h3>checking if two rectangles intersect</h3>
		there are only two cases where two rectangles <em>a</em> and <em>b</em> don’t intersect:
		<ol>
		  <li><em>trₐᵧ ≤ bl₆ᵧ</em> or <em>blₐᵧ ≥ tr₆ᵧ</em></li>
		  <li><em>blₐₓ ≥ tr₆ₓ</em> or <em>trₐₓ ≤ bl₆ₓ</em></li>
		</ol>
		in all other cases, the rectangles intersect.
		<h4>implementation</h4>
		<pre><code>
		bool intersect(vector<int> s1, vector<int> s2) {
			int bl_a_x = s1[0], bl_a_y = s1[1], tr_a_x = s1[2], tr_a_y = s1[3];
			int bl_b_x = s2[0], bl_b_y = s2[1], tr_b_x = s2[2], tr_b_y = s2[3];
			
			// no overlap
			if (bl_a_x >= tr_b_x || tr_a_x <= bl_b_x 
					|| bl_a_y >= tr_b_y || tr_a_y <= bl_b_y) {
				return false;
			} else {
				return true;
			}
		}
		</code></pre>
		
		<h3>finding area of intersection</h3>
		<ul>
		  <li>assuming that the shape formed by the intersection of two rectangles is also rectangular..</li>
		  <li>first, find this rectangle’s length and width:</li>
		  <ul>
			<li><b>width</b> <em>= min(tr(ax), tr(bx)) - max(bl(ax), bl(bx))</em></li>
			<li><b>length</b> <em>= min(tr(ay),tr(by))-max(bl(ay),bl(by))</em></li>
		  </ul>
		  <li>if either of these values are negative, the rectangles <b>do not intersect</b>. if they are zero, the rectangles intersect at <b>a single point</b>. multiply the <b>length</b> and <b>width</b> to find the overlapping area.</li>
		<h4>implementation</h4>
		<pre><code>
		int inter_area(vector<int> s1, vector<int> s2) {
			int bl_a_x = s1[0], bl_a_y = s1[1], tr_a_x = s1[2], tr_a_y = s1[3];
			int bl_b_x = s2[0], bl_b_y = s2[1], tr_b_x = s2[2], tr_b_y = s2[3];

			return ((min(tr_a_x, tr_b_x) - max(bl_a_x, bl_b_x)) *
					(min(tr_a_y, tr_b_y) - max(bl_a_y, bl_b_y)));
			}
		</code></pre>

        </td></tr>
        </tbody></table>
    </td>
</tr>
<tr class="padding">
	<td width=100% align="center" valign="top">
        <table width=100% border="1" bgcolor="#5A5858" cellspacing="2" cellpadding="4" align="center">
        <thead type="button" class="collapsible">
            <tr bgcolor="#5A5858"><th><h2>simulation</h2></th></tr>
        </thead>
        <tbody bgcolor="#737373" class="content">
        <tr><td>
        <em>this section is mostly just solutions for practice problems! if you want to practice simulation-style problems, check out the <a href=“https://usaco.guide/problems/” target=_blank>usaco.guide</a> for a full list!</em>
		<br>
		&#10159; if there’s <b>no formal algorithm</b> involved in a problem, the intent of the problem is to test your knowledge of your programming language of choice and knowledge of built-in <b>data structures</b> (refer to previous notes)!<br>
		&#10159; in USACO bronze, when a problem statement wants you to find an end result of the process (or find when something occurs), it’s usually a good idea to simulate the process <b>naively</b>.<br>
		&nbsp; (<b>naively</b> means solutions that have the most intuitive/direct solutions.)
		<h3>example 1</h3>
		(view the actual problem <a href=”http://www.usaco.org/index.php?page=viewproblem2&cpid=891” target=_blank>here</a>)
		<br><br>
		<b>shell game</b>
		<ul>
		  <li>To pass the time, Bessie the cow and her friend Elsie like to play a version of a game they saw at the county fair.</li>
		  <li>To start, Bessie puts three inverted shells on a table and places a small round pebble under one of them (at least she hopes it is a pebble -- she found it on the ground in one of the pastures). Bessie then proceeds to swap pairs of shells, while Elsie tries to guess the location of the pebble.</li>
		  <li>The standard version of the game the cows saw being played at the county fair allowed the player to see the initial location of the pebble, and then required guessing its final location after all the swaps were complete.</li>
		  <li>However, the cows like to play a version where Elsie does not know the initial location of the pebble, and where she can guess the pebble location after every swap. Bessie, knowing the right answer, gives Elsie a score at the end equal to the number of correct guesses she made.</li>
		  <li>Given the swaps and the guesses, but not the initial pebble location, please determine the highest possible score Elsie could have earned.</li>
		</ul>
		<br><br>
		<em>*note: the input and out format is just how old usaco problems were formatted. when competing in the actual competition, don’t worry about it as this is not how more recent problems will be solved!*</em><br>
		<b>INPUT FORMAT (file shell.in):</b><br>
		The first line of the input file contains an integer <em>N</em> giving the number of swaps <em>(1≤N≤100)</em>. Each of the next <em>N </em>lines describes a step of the game and contains three integers <em>a</em>, <em>b</em>, and <em>g</em>, indicating that shells <em>a </em>and <em>b</em> were swapped by Bessie, and then Elsie guessed shell <em>g</em> after the swap was made. All three of these integers are either 1, 2, or 3, and <em>a≠b</em>.
		<br><br>
		<b>OUTPUT FORMAT (file shell.out):</b><br>
		Please output the maximum number of points Elsie could have earned.
		<br><br>
		<h4>SAMPLE INPUT:</h4><br>
		<pre><code>
		3
		1 2 1
		3 2 1
		1 3 1
		</code></pre>
		<h4>SAMPLE OUTPUT:</h4><br>
		<pre><code>
		2
		</code></pre>
		In this example, Elsie could have earned at most 2 points. If the pebble started under shell 1, then she guesses right exactly once (her final guess). If the pebble started under shell 2, then she guesses right twice (the first two guesses). If the pebble started under shell 3, then she doesn't make any correct guesses.
		<br><br>
		<h4>solution:</h4>
		we can <b>simulate</b> this process by making an array that stores the position of each shell and its location. the swapping can be <b>simulated</b> by swapping the elements in each array. then, we count how many times each shell is guessed, and the maximum number of points that can be earned is equal to the maximum number of times a shell is guessed.<br>
		<pre><code>
		#include <cstdio>
		#include <vector>
		#include <algorithm>

		using std::vector;

		int main() {
			freopen("shell.in", "r", stdin);
			int n;
			scanf("%d", &n);
			/*
			again, this is just the old method of input/output used by usaco
			*/

			// shell_at_pos[i] stores the label of the shell located at position i
			vector<int> shell_at_pos(3); // vector has a length of 3
			// Place the shells down arbitrarily
			for (int i = 0; i < 3;i++) {
				shell_at_pos[i] = i; 
			} // now shell_at_pos = {0, 1, 2}
			
			// counter[i] stores the number of times the shell with label i was picked
			vector<int> counter(3); 
			for (int i = 0; i < n; i++) {
				int a, b, g;
				scanf("%d %d %d", &a, &b, &g); // puts the three ints inputed into variables a, b, g
				// Zero indexing: offset all positions by 1 (because positioning starts with 0)
				a--, b--, g--;

				// Perform Bessie's swapping operation
				std::swap(shell_at_pos[a], shell_at_pos[b]);
				// Count the number of times Elsie guesses each particular shell
				counter[shell_at_pos[g]]++;
			}
			
			freopen("shell.out", "w", stdout); // opens an empty output file "shell.out"
			printf("%d\n", std::max({counter[0], counter[1], counter[2]}));
		}
		</code></pre>
		if you don’t understand any of the code, i found that the most useful cpp documentation website is <a href=”https://cplusplus.com/reference/” target=_blank>cplusplus.com</a>! but if you still don’t get it, maybe try <a href=”https://stackoverflow.com/” target=_blank>stack overflow</a>?
		<br><br>
		<h3>example 2</h3>
		(view the actual problem <a href=”http://www.usaco.org/index.php?page=viewproblem2&cpid=855” target=_blank>here</a>)
		<br><br>
		<b>mixing milk</b><br>
		(i don’t know why all of these problems are about cows…)
		<ul>
		  <li>Farming is competitive business -- particularly milk production. Farmer John figures that if he doesn't innovate in his milk production methods, his dairy business could get creamed!</li>
		  <li>Fortunately, Farmer John has a good idea. His three prize dairy cows Bessie, Elsie, and Mildred each produce milk with a slightly different taste, and he plans to mix these together to get the perfect blend of flavors.</li>
		  <li>To mix the three different milks, he takes three buckets containing milk from the three cows. The buckets may have different sizes, and may not be completely full. He then pours bucket 1 into bucket 2, then bucket 2 into bucket 3, then bucket 3 into bucket 1, then bucket 1 into bucket 2, and so on in a cyclic fashion, for a total of 100 pour operations (so the 100th pour would be from bucket 1 into bucket 2). When Farmer John pours from bucket <em>a </em>into bucket <em>b</em>, he pours as much milk as possible until either bucket <em>a </em>becomes empty or bucket <em>b </em>becomes full.</li>
		  <li>Please tell Farmer John how much milk will be in each bucket after he finishes all 100 pours.</li>
		</ul>
		<b>INPUT FORMAT (file mixmilk.in):</b><br>
		The first line of the input file contains two space-separated integers: the capacity <em>c₁ </em> of the first bucket, and the amount of milk <em>m₁</em> in the first bucket. Both <em>c₁ </em> and <em>m₁ </em> are positive and at most 1 billion, with <em>c₁≥m₁ </em>. The second and third lines are similar, containing capacities and milk amounts for the second and third buckets.<br>
		<b>OUTPUT FORMAT (file mixmilk.out):</b></br>
		Please print three lines of output, giving the final amount of milk in each bucket, after 100 pour operations.<br>
		<h4>SAMPLE INPUT:</h4><br>
		<pre><code>
		10 3
		11 4 
		12 5
		</code></pre>
		<h4>SAMPLE OUTPUT:</h4><br>
		<pre><code>
		0
		10
		2
		</code></pre>
		In this example, the milk in each bucket is as follows during the sequence of pours:
		<pre><code>
		Initial State: 3  4  5
		1. Pour 1->2:  0  7  5
		2. Pour 2->3:  0  0  12
		3. Pour 3->1:  10 0  2
		4. Pour 1->2:  0  10 2
		5. Pour 2->3:  0  0  12
		(The last three states then repeat in a cycle ...)
		</code></pre>
		<b>solution</b><br>
		we can <b>simulate</b> the process of pouring milk into a bucket. the amount of milk poured from bucket <em>i</em> to bucket <em>j</em> is smaller than the amount of milk in bucket <em>i</em>,(or <em>mᵢ</em>) and the remaining space left in bucket <em>j</em> (or <em>cⱼ-mⱼ</em>). use an array <em>c</em> to store the maximum capacities of each bucket, and an array <em>m</em> to store the current milk level in each bucket, handling all the operations in order.
		<pre><code>
		#include <cstdio>
		#include <iostream>
		#include <vector>
		#include <algorithm>

		const int N = 3;  // The number of buckets (which is 3)
		const int TURN_NUM = 100; // Because we need to pour 100 times!

		int main() {
			freopen("mixmilk.in", "r", stdin);

			// capacity[i] is the maximum capacity of bucket i
			vector<int> capacity(N);
			// milk[i] is the current amount of milk in bucket i
			vector<int> milk(N);
			for (int i = 0; i < N; i++) {
				scanf("%d %d", &capacity[i], &milk[i]); // adding values to each array
			}

			for (int i = 0; i < TURN_NUM; i++) {
				int bucket1 = i % N;
				int bucket2 = (i + 1) % N;

				/*
				 * The amount of milk to pour is the minimum of the remaining milk
				 * in bucket 1 and the available capacity of bucket 2
				 */
				int amt = min(milk[bucket1], capacity[bucket2] - milk[bucket2]);

				milk[bucket1] -= amt;
				milk[bucket2] += amt;
			}

			freopen("mixmilk.out", "w", stdout);
			for (int m : milk) {
				cout << m << '\n';
			}
		}
		</code></pre>

        </td></tr>
        </tbody></table>
    </td>
</tr>
</table>


<!-- javascript: -->
<script>
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.display === "block") {
      content.style.display = "none";
    } else {
      content.style.display = "block";
    }
  });
}
</script>
</body>
</html>